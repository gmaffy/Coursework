seq1="GTTCGAATATTTCTATAGCTGTACATATTGTAATGCTGATAACTAATACTGTGCGCTTGACTGTGATCCTGATAAATAACTTCTTCTGTAGGGTAGAGTTTTATTTAAGGCTACTCACTGGTTGCAAACCAATGCCGTACATTACTAGCTTGATCCTTGGTCGGTCATTGGGGGATATCTCTTACTAATAGAGCGGCCTATCGCGTATTCTCGCCGGACCCCCCTCTCCCACACCAGCGGTGTAGCATCACCAAGAAAATGAGGGGAACGGATGAGGAACGAGTGGGGGCTCATTGCTGATCATAATGACTGTTTATATACTAATGCCGTCAACTGTTTGCTGTGATACTGTGCTTTCGAGGGCGGGAGATTCGTTTTTGACATACATAAATATCATGACAAAACAGCCGGTCATGACAAAACAGCCGGTCATAATAGATTAGCCGGTGACTGTGAAACTAAAGCTACTAATGCCGTCAATAAATATGATAATAGCAACGGCACTGACTGTGAAACTAAAGCCGGCACTCATAATAGATTAGCCGGAGTCGTATTCATAGCCGGTAGATATCACTATAAGGCCCAGGATCATGATGAACACAGCACCACGTCGTCGTCCGAGTTTTTTTGCTGCGACGTCTATACCACGGAAGCTGATCATAAATAGTTTTTTTGCTGCGGCACTAGAGCCGGACAAGCACACTACGTTTGTAAATACATCGTTCCGAATTGTAAATAATTTAATTTCGTATTTAAATTATATGATCACTGGCTATAGTCTAGTGATAACTACAATAGCTAGCAATAAGTCATATATAACAATAGCTGAACCTGTGCTACATATCCGCTATACGGTAGATATCACTATAAGGCCCAGGACAATAGCTGAACTGACGTCAGCAACTACGTTTAGCTTGACTGTGGTCGGTTTTTTTGCTGCGACGTCTATACGGAAGCTCATAACTATAAGAGCGGCACTAGAGCCGGCACACAAGCCGGCACAGTCGTATTCATAGCCGGCACTCATGACAAAACAGC"

seq2="CAACTGGCAGCATAAAACATATAGAACTACCTGCTATAAGTGATACAACTGTTTTCATAGTAAAACATACAACGTTGCTGATAGTACTCCTAAGTGATAGCTTAGTGCGTTTAGCATATATTGTAGGCTTCATAATAAGTGATATTTTAGCTACGTAACTAAATAAACTAGCTATGACTGTACTCCTAAGTGATATTTTCATCCTTTGCAATACAATAACTACTACATCAATAGTGCGTGATATGCCTGTGCTAGATATAGAACACATAACTACGTTTGCTGTTTTCAGTGATATGCTAGTTTCATCTATAGATATAGGCTGCTTAGATTCCCTACTAGCTATTTCTGTAGGTGATATACGTCCATTGCATAAGTTAATGCATTTAACTAGCTGTGATACTATAGCATCCCCATTCCTAGTGCATATTTTCATCCTAGTGCTACGTGATATAATTGTACTAATGCCTGTAGATAATTTAATGCCTGGCTCGTTTGTAGGTGATAATTTAGTGCCTGTAAAACATATACCTGAGTGCTCGTTGCGTGATAGTTCGTTCATGCATATACAACTAGGCTGCTGTGATATGGTCACTGCCCTTACTGTGCTACATATTACTGCGAGGGGGATGACGTATAAACCTGTTGTAAGTGATATGACGTATATAACTACTAGTGATATGACGTATAGGCTAGAACAACGTGATATGACGTATATGACTACTGTCCCAAACATCAGTGATATGACGTATACTATAATTTCTATAATAGTGATAAATAAACCTGGGCTAAATACGTTCCTGAATACGTGGCATAAACCTGGGCTAACGAGGAATACCCATAGTTTAGCAATAAGCTATAGTTCGTCATTTTTAA"

seq3="TTTAACCATATTTAAATATCATCCTGATTTTCACTGGCTCGTTGCGTGATATAGATTCTACTGTAGTGCTAGATAGTTCTGTACTAGGTGATACTATAGATTTCATAGATAGCACTACTGGCTTCATGCTAGGCATCCCAATAGCTAGTGATAGTTTAGTGCATACAACGTCATGTGATACAACGTTGCTGGCTGTAGATACAACGTCGTATTCTGTAAGTGATACAATAGCTATTGCTGTGCATAGGCCTATAGTGGCTGTAACTAGTGATATCACGTAACAACCATATAAGTTAGATTTAATGCCCCTGACTGAACGCTCGTTGCGTGATAGTTTAGGCTCGTTGCATACAACTGTGATTTTCATAAAACAACGTGATAATTTAGTGCTAGATAAGTTCCGCTTAGCAAGTGATAGTTTCCGCTTGACTGTGCATAGTTCGTTCATGCGCTCGTTGCGTGATAAACTAGGCAGCTTCACAACTGATAATTTAATTGCTGATATTGCTGGCTGTCTAGTGCTAGTGATCATAGTGCGTGATAGTTTAAGCTGCTCTGTTTTAGATATCACGTGCTTGATAATGAAACTAACTAGTGATACTACGTAGTTAACTATGAATAGGCCTACTGTAAATTCAATAGTGCGTGATATTGAACTAGATTCTGCAACTGCTAATATGCCGTGCTGCACGTTTGGTGATAGTTTAGCATGCTTCACTATAATAAATATGGTAGTTGTAACTACTGCGAATAGGGGGAGCTTAATAAATATGATCACTGTGCTACGCTATATGCCGTTGAATATAGGCTATATGATCATAACATATATAGCTATAAGTGATAAGTTCCTGAATATAGGCTATATGATCATAACATATACAACTGTACTCATGAATAAGTTAACGAGGA"

seq4="TTTCATTGCTGATCACTGTAGATATAGTGCATTCTATAAGTCGCTCCCACAGGCTAGTGCTGCGCACGTTTTTCAGTGATATTATCCTAGTGCTACATAACATCATAGTGCGTGATAAACCTGATACAATAGGTGATATCATAGCAACTGAACTGACGTTGCATAGCTCAACTGTGATCAGTGATATAGATTCTGATACTATAGCAACGTTGCGTGATATTTTCACTACTGGCTTGACTGTAGTGCATATGATAGTACGTCTAACTAGCATAACTAGTGATAGTTATATTTCTATAGCTGTACATATTGTAATGCTGATAACTAGTGATATAATCCAACTAGATAGTCCTGAACTGATCCCTATGCTAACTAGTGATAAACTAACTGATACATCGTTCCTGCTACGTGATAGCTTCACTGAGTTCCATACATCGTCGTGCTTAAACATCAGTGATAACACTATAGAGTTCATAGATACTGCATTAACTAGTGATATGACTGCAAATAGCTTGACGTTTTGCAGTCTAAAACAACGTGATAATTCTGTAGTGCTAGATACTATAGATTTCCTGCTAAGTGATAAGTCTACTGATTTACTAATGAATAGCTTGGTTTTGGCATACACTGTGCGCTGCACTGGTGATAGCTTTTCGTTGATGAATAATTTCCCTAGCACTGTGCGTGATATGCTAGATTCTGTAGATAGGCTAAATTCGTCTACGTTTGTAGGTGATAGTTTAGTTGCTGTAACTAATATTATCCCTGTGCCGTTGCTAAGCTGTGATATCATAGTGCTGCTAGATATGATAAGCAAACTAATAGAGTCGAGGGGGAGTCTCATAGTGAATACTGATATTTTAGTGCTGCCGTTGAATAAGTTCCCTGAACATTGTGATACTGATATTTTAGTGCTGCCGTTGAATATCCTGCATTTAACTAGCTTGATAGTGCATTCGAGGAATACCCATACTACTGTTTTCATAGCTAATTATAGGCTAACATTGCCAATAGTGC"

seq=[seq1,seq2,seq3,seq4]

quote1="TO LIVE, TO ERR, TO FALL, TO TRIUMPH, TO RECREATE LIFE OUT OF LIFE."

quote2="SEE THINGS NOT AS THEY ARE, BUT AS THEY MIGHT BE."

quote3="WHAT I CANNOT BUILD, I CANNOT UNDERSTAND."

quoteArray = [quote1, quote2, quote3]

def codonMap(codon):
    if codon == "TTT":
        return 0
    elif codon == "TTC":
        return 1
    elif codon == "TTA":
        return 2
    elif codon == "TTG":
        return 3
    elif codon == "CTT":
        return 4
    elif codon == "CTC":
        return 5
    elif codon == "CTA":
        return 6
    elif codon == "CTG":
        return 7
    elif codon == "ATT":
        return 8
    elif codon == "ATC":
        return 9
    elif codon == "ATA":
        return 10
    elif codon == "ATG":
        return 11
    elif codon == "GTT":
        return 12
    elif codon == "GTC":
        return 13
    elif codon == "GTA":
        return 14
    elif codon == "GTG":
        return 15

    elif codon == "TCT":
        return 16
    elif codon == "TCC":
        return 17
    elif codon == "TCA":
        return 18
    elif codon == "TCG":
        return 19
    elif codon == "CCT":
        return 20
    elif codon == "CCC":
        return 21
    elif codon == "CCA":
        return 22
    elif codon == "CCG":
        return 23
    elif codon == "ACT":
        return 24
    elif codon == "ACC":
        return 25
    elif codon == "ACA":
        return 26
    elif codon == "ACG":
        return 27
    elif codon == "GCT":
        return 28
    elif codon == "GCC":
        return 29
    elif codon == "GCA":
        return 30
    elif codon == "GCG":
        return 31

    elif codon == "TAT":
        return 32
    elif codon == "TAC":
        return 33
    elif codon == "TAA":
        return 34
    elif codon == "TAG":
        return 35
    elif codon == "CAT":
        return 36
    elif codon == "CAC":
        return 37
    elif codon == "CAA":
        return 38
    elif codon == "CAG":
        return 39
    elif codon == "AAT":
        return 40
    elif codon == "AAC":
        return 41
    elif codon == "AAA":
        return 42
    elif codon == "AAG":
        return 43
    elif codon == "GAT":
        return 44
    elif codon == "GAC":
        return 45
    elif codon == "GAA":
        return 46
    elif codon == "GAG":
        return 47

    elif codon == "TGT":
        return 48
    elif codon == "TGC":
        return 49
    elif codon == "TGA":
        return 50
    elif codon == "TGG":
        return 51
    elif codon == "CGT":
        return 52
    elif codon == "CGC":
        return 53
    elif codon == "CGA":
        return 54
    elif codon == "CGG":
        return 55
    elif codon == "AGT":
        return 56
    elif codon == "AGC":
        return 57
    elif codon == "AGA":
        return 58
    elif codon == "AGG":
        return 59
    elif codon == "GGT":
        return 60
    elif codon == "GGC":
        return 61
    elif codon == "GGA":
        return 62
    elif codon == "GGG":
        return 63
    else:
        return "N"

def codonCatcher(sequence):
    frame1=[]
    frame2=[]
    frame3=[]


    for i in range(0,len(sequence),3):
        if not i+2>len(sequence):
            frame1.append(sequence[i:i+3])
            
        else:
            break


    for i in range(1,len(sequence),3):
        if not i+2>len(sequence):
            frame2.append(sequence[i:i+3])
           
        else:
            break

    

    for i in range(2,len(sequence),3):
        if not i+2>len(sequence):
            frame3.append(sequence[i:i+3])
           
        else:
            break
    return[frame1,frame2,frame3]

mapping=[[[],[],[]],[[],[],[]],[[],[],[]],[[],[],[]]]



for m in range(0,4):
    x=codonCatcher(seq[m])
    for i in range(0,len(x)):
    
        for n in range(0,len(x[i])):

            mapping[m][i].append(codonMap(x[i][n]))

def repeat4(sequence):
    indices=[]
    for i in range(0,len(sequence)-4):
        if sequence[i:i+4]==sequence[i+12:i+16]:
            indices.append(i)
    return indices

#quote1 has several repeating sequences separated by 12 spaces. Determine which reading frame of which watermark matches it

def mapquote1():
    quoteIndex = None
    mapIndex = None
    firstRepeat4=None
    distanceToEnd=None
    
    for i in range(0,len(mapping)):
        for n in range(0,len(mapping[i])):
                       for m in range(0,len(quoteArray)):
                                      if len(repeat4(quoteArray[m]))==len(repeat4(mapping[i][n]))>0:
                                                                        quoteIndexList = repeat4(quoteArray[m])
                                                                        mappingIndexList = repeat4(mapping[i][n])
                                                                        if mappingIndexList[1] == quoteIndexList[1]+(mappingIndexList[0]-quoteIndexList[0]):
                                                                            quoteIndex=m
                                                                            mapIndex=[i, n]
                                                                            firstRepeat4_seq=mappingIndexList[0]
                                                                            firstRepeat4_quote=quoteIndexList[0]
                                                                            distanceToEnd=len(quoteArray[m])-quoteIndexList[0]
                                                                            

    return [quoteIndex, mapIndex, firstRepeat4_seq,distanceToEnd,firstRepeat4_quote]
                                                                                 
    
quote1mapping=mapquote1()
translationTable={}

counter=0
for i in range(quote1mapping[2],quote1mapping[2]+quote1mapping[3]):
    translationTable[mapping[quote1mapping[1][0]][quote1mapping[1][1]][i]]=quote1[quote1mapping[4]+counter]
    counter+=1
translationTable[mapping[quote1mapping[1][0]][quote1mapping[1][1]][quote1mapping[2]+quote1mapping[3]+1]]=' '
translationTable[mapping[quote1mapping[1][0]][quote1mapping[1][1]][quote1mapping[2]+quote1mapping[3]]]='"'

#only letter in quote1 now missing from table should be 'v'. Let's add it now
translationTable[mapping[quote1mapping[1][0]][quote1mapping[1][1]][quote1mapping[2]-(quote1mapping[4]-quote1.find("V"))]]="V"


def translate(sequence):
    translation=[]
    for i in range(0,len(sequence)):
        if sequence[i] in translationTable:
            translation.append(translationTable[sequence[i]])
        else:
            translation.append(sequence[i])

    return translation

#at this point, the correct reading frame is likely to be the one that can be translated most by the existing translation table

def countTranslatedCodons(sequence):

    translation = translate(sequence)

    counter=0
    for i in range(0,len(translation)):
        if type(translation[i])!=type(1):
            counter+=1
    return counter

def chooseReadingFrame(sequence):
    readingFrames=[1,1,1,1]#arbitraily set to 1
    for i in range(0,len(sequence)):
        for n in range(0,len(sequence[i])):
            if countTranslatedCodons(mapping[i][n])>countTranslatedCodons(mapping[i][readingFrames[i]]):
                readingFrames[i]=n
    return readingFrames

readingFrames = chooseReadingFrame(mapping)

#now we can eliminate the unused frames from our mapping
correctMapping=[]
for i in range(0,len(readingFrames)):
    correctMapping.append(mapping[i][readingFrames[i]])

#use quote2 to further build the translation table
#we will now search for the pattern 'EE THI', as this should be able to be translated using letters in the first quote

def findEE_THI(translationList):

    translations=[]
    for m in range(0,len(translationList)):
        translations.append(translate(translationList[m]))

    blockStart=None
    watermark=None
    
    for n in range(0,len(translations)):
        for i in range(0,len(translations[n])-6):
            if translations[n][i:i+6]==['E', 'E', ' ', 'T', 'H', 'I']:
                blockStart=i
                watermark=n

    return [watermark, blockStart]


quote2_mapping=findEE_THI(correctMapping)

counter=0
translationTable[correctMapping[quote2_mapping[0]][quote2_mapping[1]-1]]="S"
for i in range(quote2_mapping[1],quote2_mapping[1]+len(quote2)-2):
    translationTable[correctMapping[quote2_mapping[0]][i]]=quote2[counter+1]
    counter+=1

#only letter in quote1 now missing from table should be 'v'. Let's add it now
translationTable[mapping[quote1mapping[1][0]][quote1mapping[1][1]][quote1mapping[2]-(quote1mapping[4]-quote1.find("V"))]]="V"

#now we can use the final quote, quote 3, to break the code!
#we will search for HAT_I_CAN, since this should be recognizable using existing letters

def findHAT_I_CAN(translationList):

    translations=[]
    for m in range(0,len(translationList)):
        translations.append(translate(translationList[m]))

    blockStart=None
    watermark=None
    
    for n in range(0,len(translations)):
        for i in range(0,len(translations[n])-9):
            if translations[n][i:i+9]==['H', 'A', 'T', ' ', 'I', ' ', 'C', 'A','N']:
                blockStart=i
                watermark=n

    return [watermark, blockStart]


quote3_mapping=findHAT_I_CAN(correctMapping)

counter=0
translationTable[correctMapping[quote3_mapping[0]][quote3_mapping[1]-1]]="W"
for i in range(quote3_mapping[1],quote3_mapping[1]+len(quote3)-2):
    translationTable[correctMapping[quote3_mapping[0]][i]]=quote3[counter+1]
    counter+=1

#now, translate the sequences
def list2string(lst):
    string=''
    for i in range(0,len(lst)):
        if type(lst[i])!=type(1):
            string+=lst[i]
        else:
            string+='?'
    return string

for i in range(0,4):
    print(list2string(translate(correctMapping[i])))
    print()
